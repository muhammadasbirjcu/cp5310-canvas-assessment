<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>CP5310 Assessment 1</title>

        <!-- Bootstrap CSS Framework -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">

        <!-- Fontawesome Icons -->
        <script src="https://kit.fontawesome.com/54ebba3642.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <div class="vh-100">
            <div id="toolbar" class="bg-primary bg-gradient px-3 py-2 d-block d-md-flex" style="height:50px">
                <div class="btn-group me-md-3" style="flex:0 0 150px">
                    <label for="load-file-input" id="load-file" class="btn btn-light btn-sm"><i class="fa-solid fa-file"></i> Load</label>
                    <button id="save-file" class="btn btn-light btn-sm"><i class="fa-solid fa-floppy-disk"></i> Save</button>
                </div>

                <div class="btn-group" style="flex:0 0 150px">
                    <button id="clear-canvas" class="btn btn-light btn-sm"><i class="fa-solid fa-eraser"></i> Clear</button>
                    <button id="undo" class="btn btn-light btn-sm"><i class="fa-solid fa-rotate-left"></i> Undo</button>
                </div>

                <div class="btn-group" style="flex:1 1 100px">
                </div>

                <div class="btn-group" style="flex:0 0 150px">
                    <button id="edit-mode" class="btn btn-light btn-sm"><i class="fa-solid fa-pencil"></i> Edit</button>
                    <button id="view-mode" class="btn btn-light btn-sm"><i class="fa-solid fa-tv"></i> View</button>
                </div>


                <input type="file" id="load-file-input" class="d-none">
            </div>
            <!-- <div id="background-guide"></div> -->
            <canvas id="main-canvas"></canvas>
        </div>


        
        <style type="text/css">
            /* clears all padding margin */
            *{
                padding:0;
                margin:0;
                box-sizing: border-box;
            }
            #main-canvas{
                border:3px solid #000;
                display: block;
                box-sizing: border-box;

                position: relative;
                z-index: 9;
            }
            #background-guide{
                background: url(guide.png) center center no-repeat;
                position: fixed;
                top:0;
                left:0;
                width: 100%;
                height: 100%;
            }
            
        </style>
        <script>
            // set the default values
            const defaultValues = {
                circle: {
                    radius: 7,
                    fillColor: '#000'
                },
                line: {
                    width: 7,
                    strokeGradient: [
                        { color: 'blue', position: 0 },
                        { color: 'red', position: 0.5 },
                        { color: 'yellow', position: 1 },
                    ]
                }
            }

            var pointCoordinates = [];

            // offset is used in animating the whole drawing
            var offset = {
                x: 0,
                y: 0
            }

            // variables
            const canvas = document.getElementById("main-canvas");
            const canvasContext = canvas.getContext('2d');
            const editModeButton = document.getElementById("edit-mode");
            const viewModeButton = document.getElementById("view-mode");
            var mode = null;
            var drawIndex = 0;
            var drawInterval = null;

            /**
             * ---------------------------
             * BASIC LINE AND CIRCLE DRAW
             * ---------------------------
             */
            function plotCircle(context, centreX, centreY)
            {
                context.beginPath();
                context.arc(centreX + offset.x, centreY + offset.y, defaultValues.circle.radius, 0, 2*Math.PI);
                context.fillStyle = defaultValues.circle.fillColor;
                context.fill();
            }

            function drawLine(context, startX, startY, endX, endY)
            {
                context.beginPath();
                // define start and end coordinates
                const start = {
                    x: startX + offset.x,
                    y: startY + offset.y
                }
                const end = {
                    x: endX + offset.x,
                    y: endY + offset.y
                }
                // create the line
                context.moveTo(start.x, start.y);
                context.lineTo(end.x, end.y);
                context.lineWidth = defaultValues.line.width;
                context.strokeStyle = createGradient(context, start.x, start.y, end.x, end.y);
                context.stroke();
            }

            function createGradient(context, startX, startY, endX, endY)
            {
                var grad = context.createLinearGradient(startX, startY, endX, endY);
                for(var i in defaultValues.line.strokeGradient){
                    grad.addColorStop(defaultValues.line.strokeGradient[i].position, defaultValues.line.strokeGradient[i].color);
                }
                return grad;
            }


            /**
             * -----------------------
             * CANVAS FUNCTIONS
             * -----------------------
             */
            function drawPoints(context, points)
            {
                for(var i in points){
                    plotCircle(context, points[i].x, points[i].y);
                    if(i > 0){
                        drawLine(context, points[i-1].x, points[i-1].y, points[i].x, points[i].y);
                    }
                }
            }

            function clearCanvas(context, canvas)
            {
                context.clearRect(0, 0, canvas.width, canvas.height);
            }

            function redrawPoints(context, canvas, points)
            {
                clearCanvas(context, canvas);
                drawPoints(context, points);
            }

            function undoLastPoint(content, canvas, points)
            {
                if(pointCoordinates.length < 1) return;
                pointCoordinates.pop();
                redrawPoints(content, canvas, points);
            }

            function lastCoordinate()
            {
                return pointCoordinates.length > 0 ? 
                    pointCoordinates[pointCoordinates.length - 1] : 
                    null;
            }


            /**
             * -----------------------
             * LOAD AND SAVE TO FILE
             * -----------------------
             */
            function saveToFile(points)
            {
                location.href = "data:application/octet-stream," + encodeURIComponent(JSON.stringify(points));
            }

            function initLoadFile()
            {
                const fileInput = document.getElementById('load-file-input');
                fileInput.addEventListener('change', (event) => {
                    if(pointCoordinates.length > 0){
                        // confirm is user want to load
                        const confirmed = confirm("Loading a new file will overwrite your current work. Proceed?");
                        if(!confirmed) return; // terminate
                    }
                    const fileList = event.target.files;
                    // if any file is selected
                    if(fileList && fileList.length > 0){
                        const loadedFile = fileList[0];

                        // check file type
                        if (loadedFile.type && loadedFile.type.toLowerCase() == 'application/json') {
                            // if the selected file is json, load file content
                            loadPointsFromFile(loadedFile);
                        }else{
                            alert("Invalid file type!");
                            return;
                        }
                    }
                });
            }

            function loadPointsFromFile(file)
            {
                const reader = new FileReader();
                reader.addEventListener('load', (event) => {
                    var jsonData = [];
                    try{
                        jsonData = JSON.parse(event.target.result);
                        if (!Array.isArray(jsonData)) throw "Json data is not array";
                        // validate each item in array
                        for(var i in jsonData){
                            if(jsonData[i].hasOwnProperty('x') && jsonData[i].hasOwnProperty('y')){
                                // valid structure
                            }else{
                                throw "Invalid data structure at item " + i;
                            }
                        }
                    }catch(err){
                        alert(err);
                    }

                    // assign to points
                    pointCoordinates = jsonData;
                    redrawPoints(canvasContext, canvas, pointCoordinates);
                });
                reader.readAsText(file);
            }

            /**
             * -----------------------
             * MODES
             * -----------------------
             */
            function viewMode(cotext, canvas)
            {
                // do nothing if mode is already in 'edit' mode
                if(mode == 'view') return; 
                // toggle button classes
                editModeButton.classList.remove("btn-dark");
                viewModeButton.classList.add("btn-dark");
                mode = 'view';

                // stop any pending animation
                if(drawInterval) clearInterval(drawInterval);

                // clear canvas
                clearCanvas(cotext, canvas);

                if(pointCoordinates.length == 0) return;

                // start from beginning
                drawIndex = 0;
                drawInterval = setInterval(function(){
                    // start animation
                    if(drawIndex < pointCoordinates.length){
                        plotCircle(canvasContext, pointCoordinates[drawIndex].x, pointCoordinates[drawIndex].y);
                        if(drawIndex > 0){
                            drawLine(canvasContext, pointCoordinates[drawIndex-1].x, pointCoordinates[drawIndex-1].y, pointCoordinates[drawIndex].x, pointCoordinates[drawIndex].y);
                        }
                        drawIndex++;
                    }else{
                        drawIndex = 0;
                        clearCanvas(cotext, canvas);
                    }
                }, 1000);
            }

            function editMode(cotext, canvas)
            {
                // do nothing if mode is already in 'view' mode
                if(mode == 'edit') return; 
                // toggle button classes
                editModeButton.classList.add("btn-dark");
                viewModeButton.classList.remove("btn-dark");
                mode = 'edit';

                // stop any pending animation
                if(drawInterval) clearInterval(drawInterval);

                // clear canvas
                clearCanvas(cotext, canvas);

                // redraw
                redrawPoints(canvasContext, canvas, pointCoordinates);
            }

            // this part make sure the canvas covers the whole viewport/window
            var toolbarHeight = 50;
            var borderWidth = 2;
            canvas.width = window.innerWidth - (borderWidth*3);
            canvas.height = window.innerHeight - toolbarHeight - (borderWidth*3);

            // load from last session - if there's any
            if(localStorage.getItem('canvas_points')){
                pointCoordinates = JSON.parse(localStorage.getItem('canvas_points'));
            }

            // handles load file
            initLoadFile();

            // start with edit mode
            editMode(canvasContext, canvas);

            // bind listeners
            // on clicks of save file
            document.getElementById("save-file").addEventListener("click", function(event) {
                saveToFile(pointCoordinates);
            });
            // on clicks of clear canvas
            document.getElementById("clear-canvas").addEventListener("click", function(event) {
                if(confirm("Are you sure you want to clear?")){
                    pointCoordinates = [];
                    clearCanvas(canvasContext, canvas);
                }
            });
            // on clicks of undo
            document.getElementById("undo").addEventListener("click", function(event) {
                undoLastPoint(canvasContext, canvas, pointCoordinates);
            });
            // on clicks in canvas
            canvas.addEventListener("click", function(event) {
                if(mode == 'edit'){
                    const prevLastCoordinate = lastCoordinate();
                    pointCoordinates.push({x:event.offsetX, y:event.offsetY});
                    const newLastCoordinate = lastCoordinate();
                    
                    if(prevLastCoordinate == null){
                        plotCircle(canvasContext, newLastCoordinate.x, newLastCoordinate.y);
                    }else{
                        drawLine(canvasContext, prevLastCoordinate.x, prevLastCoordinate.y, newLastCoordinate.x, newLastCoordinate.y);
                        plotCircle(canvasContext, newLastCoordinate.x, newLastCoordinate.y);
                    }
                } 
                
            });
            // store unsaved changes to localStorage
            window.addEventListener('beforeunload', function(event) {
                localStorage.setItem('canvas_points', JSON.stringify(pointCoordinates));
            });

            // on clicks in canvas
            editModeButton.addEventListener("click", function(event) {
                editMode(canvasContext, canvas);
            });
            viewModeButton.addEventListener("click", function(event) {
                viewMode(canvasContext, canvas);
            });
            

        </script>
    </body>
</html>
